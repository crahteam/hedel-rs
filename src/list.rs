use crate::{
	cell::HedelCell,
	Node,
};
use std::{
	rc::{
		Rc,
		Weak
	},
	fmt::Debug,
};

/// `List` concreatly is a pointer to its first node.
/// This design allows for sibling nodes at the root-level.
/// 
/// Usually generated by the `list` macro.
///
/// # Example
///
/// ```
/// use hedel_rs::prelude::*;
/// use hedel_rs::*;
///
/// fn main() {
///		let list = list!(
///			node!(1, node!(2)),
///			node!(3),
///			node!(4)
///		); 
///		
///		// derefernces to the first node and retrives its first child.
///		assert_eq!(list.first().unwrap().child().unwrap().to_content(), 2);
///		assert_eq!(list.first().unwrap().get_last_sibling().unwrap().to_content(), 4);
/// }
/// ```

#[derive(Debug, Clone)]
pub struct List<T: Debug + Clone> {
	pub first: Rc<HedelCell<Option<Node<T>>>>
}

/// A weak pointer to the the first node of a list.
/// Necessaraly stored in `Node` to act on the original `List`,
/// to change its first node.
///
/// Usually built by calling `List::downgrade`.
#[derive(Debug, Clone)]
pub struct WeakList<T: Debug + Clone> {
	pub first: Weak<HedelCell<Option<Node<T>>>>
}

impl<T: Debug + Clone> List<T> {
	
	/// Builds a `List` properly given its first node 
	pub fn new(node: Node<T>) -> Self {
		let list = Self {
			first: Rc::new(HedelCell::new(Some(node.clone())))
		};
		node.get_mut().list = Some(list.downgrade());
		list
	}
	
	/// Get a weak pointer to the first node.
	pub fn downgrade(&self) -> WeakList<T> {
		WeakList::<T> {
			first: Rc::downgrade(&self.first) 
		}
	}
	
	/// Get the first node of the linked list if any.
	///
	/// # Example
	///
	/// ```
	/// use hedel_rs::prelude::*;
	/// use hedel_rs::*;
	/// 
	/// fn main() {
	///		let list = list!(node!(10));
	///		assert_eq!(list.first().unwrap().to_content(), 10);
	/// }
	/// ```
	pub fn first(&self) -> Option<Node<T>> {
		self.first.get().clone()	
	}
}

impl<T: Debug + Clone> WeakList<T> {
	pub fn upgrade(&self) -> Option<List<T>> {
		Some(List::<T> {
			first: self.first.upgrade()?
		})
	}
}

/// Generate a linked list blazingly fast and append any number of `Nodes`
/// 
/// # Example
///
/// ```
/// use hedel_rs::prelude::*;
/// use hedel_rs::*;
///
/// fn main() {
///		let my_list = list!{
///			node!(2, node!(3)),
///			node!(45),
///			node!(36)
///		};
/// }
/// ```
#[macro_export]
macro_rules! list {
	($($node: expr),*) => {
		{
			let mut children: Vec<hedel_rs::Node<_>> = Vec::new();
			let mut lists: Vec<usize> = Vec::new();
			let mut c = 0;

			$(
				let n: hedel_rs::Node::<_> = $node.into();
				
				if let Some(_) = n.get().list {
					lists.push(c as usize);
				}

				children.push(n);

				c += 1;

			)*

			if children.len() > 0 {
				
				c = 0;

				for ref child in &children {
					
					let mut borrow = child.get_mut();
					
					if c != children.len() - 1 {
						borrow.next = Some(children[c + 1].clone()); 
					}

					if c != 0 {
						borrow.prev = Some(children[c - 1].downgrade());
					}

					borrow.parent = None;

					c += 1;
				}
			}
	
			for idx in lists.into_iter() {
				
				let first = children[idx].clone();

				if idx > 0 {
					if let Some(prev) = children.get(idx - 1) {
						prev.get_mut().next = Some(first.clone());
						first.get_mut().prev = Some(prev.downgrade());
					}
				}

				if let Some(last) = first.get_last_sibling() {
					if let Some(next) = children.get(idx + 1) {
						next.get_mut().prev = Some(last.downgrade());
						last.get_mut().next = Some(next.clone());
					}
				}
			}
			// Rc<HedelCell<NodeList>>
			let list = hedel_rs::List::new(children[0].clone());
			children[0].get_mut().list = Some(list.downgrade());
			list
		}
	}
}
